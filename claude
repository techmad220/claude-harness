#!/bin/bash
# Claude Harness - Quality Enforcement for Claude CLI
# Implements code quality gates and session tracking
#
# Usage:
#   claude                    - Interactive mode (auto-creates CLAUDE.md)
#   claude "Build X"          - Full harness mode with enforcement
#   claude --harness          - Force harness mode
#   claude --raw [args]       - Bypass harness, run Claude directly

set -euo pipefail

# =========================================================================
# CONFIGURATION
# =========================================================================

# Find the real Claude binary
if [ -x "$HOME/.local/bin/claude.real" ]; then
    CLAUDE_REAL="$HOME/.local/bin/claude.real"
elif [ -d "$HOME/.local/share/claude/versions" ]; then
    CLAUDE_REAL=$(ls -t "$HOME/.local/share/claude/versions"/* 2>/dev/null | head -1)
else
    echo "ERROR: Cannot find Claude binary" >&2
    echo "Install Claude CLI first, then rename it to claude.real" >&2
    exit 1
fi

# ============================================================================
# ARGUMENT PARSING
# ============================================================================

HARNESS_MODE=""
RAW_MODE=""
INTERACTIVE_MODE=""
TASK_ARGS=""

show_help() {
    cat << 'EOF'
Claude Harness - Quality Enforcement

USAGE:
  claude                    Interactive mode (creates CLAUDE.md if needed)
  claude "task description" Full harness mode with enforcement
  claude --harness          Force harness mode
  claude --raw [args]       Bypass harness, run Claude directly
  claude --rollback         Restore last snapshot

FLAGS:
  --raw         Bypass all harness logic
  --harness     Force harness mode
  --rollback    Restore previous snapshot
  -h, --help    Show this help

ENFORCEMENT:
  - No slop (greeting phrases, filler)
  - No placeholders (TODO, FIXME, pass, stub)
  - Session tracking (initializer/continuing modes)
  - Git snapshots before changes
EOF
}

parse_arguments() {
    if [ $# -eq 0 ]; then
        INTERACTIVE_MODE="true"
        return
    fi

    while [ $# -gt 0 ]; do
        case "$1" in
            --raw)
                RAW_MODE="true"
                shift
                TASK_ARGS="$*"
                return
                ;;
            --harness)
                HARNESS_MODE="true"
                shift
                if [ $# -gt 0 ]; then
                    TASK_ARGS="$*"
                fi
                return
                ;;
            --rollback)
                do_rollback
                exit 0
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                HARNESS_MODE="true"
                TASK_ARGS="$*"
                return
                ;;
        esac
    done
}

# ============================================================================
# GLOBALS
# ============================================================================

WORK_DIR="$(pwd)"
SESSION_ID="$(date +%s)-$$"
SESSION_DIR="/tmp/claude-$SESSION_ID"
SNAPSHOT_DIR="$HOME/.claude/snapshots"
VIOLATIONS_LOG="$HOME/.claude/violations.log"

PROGRESS_FILE="$WORK_DIR/claude-progress.txt"
FEATURES_FILE="$WORK_DIR/features.json"

OUTPUT_FILE="$SESSION_DIR/output.txt"
VIOLATIONS_FILE="$SESSION_DIR/violations.txt"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

mkdir -p "$SESSION_DIR" "$SNAPSHOT_DIR"
trap 'rm -rf "$SESSION_DIR"' EXIT

# ============================================================================
# SNAPSHOT SYSTEM (ROLLBACK SAFETY)
# ============================================================================

take_snapshot() {
    local snap_id="snap-$SESSION_ID"
    local snap_path="$SNAPSHOT_DIR/$snap_id"

    if git rev-parse --git-dir >/dev/null 2>&1; then
        git stash push -m "claude-harness-$snap_id" --include-untracked 2>/dev/null || true
        git rev-parse HEAD > "$snap_path.commit" 2>/dev/null || true
        git stash pop 2>/dev/null || true

        # Also save diff for non-stash rollback
        git diff HEAD > "$snap_path.diff" 2>/dev/null || true
        git status --porcelain > "$snap_path.status" 2>/dev/null || true
    fi

    # Save file hashes for verification
    find . -type f \( -name "*.py" -o -name "*.js" -o -name "*.ts" -o -name "*.rs" -o -name "*.go" \) 2>/dev/null | \
        head -100 | while IFS= read -r f; do
            sha256sum "$f" 2>/dev/null || true
        done > "$snap_path.hashes"

    # Remember last snapshot
    echo "$snap_id" > "$SNAPSHOT_DIR/latest"

    echo "$snap_id"
}

do_rollback() {
    if [ ! -f "$SNAPSHOT_DIR/latest" ]; then
        echo -e "${RED}No snapshot available to rollback${NC}"
        exit 1
    fi

    local snap_id=$(cat "$SNAPSHOT_DIR/latest")
    local snap_path="$SNAPSHOT_DIR/$snap_id"

    echo -e "${YELLOW}Rolling back to snapshot: $snap_id${NC}"

    if [ -f "$snap_path.commit" ] && git rev-parse --git-dir >/dev/null 2>&1; then
        local commit=$(cat "$snap_path.commit")
        echo -e "${CYAN}Resetting to commit: $commit${NC}"
        git reset --hard "$commit" 2>/dev/null || true

        if [ -f "$snap_path.diff" ] && [ -s "$snap_path.diff" ]; then
            echo -e "${CYAN}Applying saved changes...${NC}"
            git apply "$snap_path.diff" 2>/dev/null || true
        fi
    fi

    echo -e "${GREEN}‚úÖ Rollback complete${NC}"
}

# ============================================================================
# SECURITY CHECKS
# ============================================================================

# False positive contexts - these patterns indicate safe/educational usage
is_false_positive() {
    local output="$1"
    local category="$2"

    # Check for documentation/comment context
    if grep -qE "(#.*example|//.*example|/\*.*example|\*.*example|>>>|docstring|documentation|tutorial|README|\.md:|test_|_test\.py|spec\.js|\.spec\.ts)" <<< "$output"; then
        return 0
    fi

    # Check for safe alternatives being shown
    case "$category" in
        "SQLi")
            # Safe if using parameterized queries nearby
            if grep -qE "(parameterized|prepared statement|\?.*%s.*execute|cursor\.execute.*,\s*\(|\.query\(.*,\s*\[)" <<< "$output"; then
                return 0
            fi
            ;;
        "XSS")
            # Safe if using sanitization
            if grep -qE "(sanitize|escape|encode|DOMPurify|textContent|createTextNode)" <<< "$output"; then
                return 0
            fi
            ;;
        "CMDi")
            # Safe if using safe alternatives
            if grep -qE "(shlex\.quote|subprocess\.run\(\[|shell=False|execFile)" <<< "$output"; then
                return 0
            fi
            ;;
        "SSRF")
            # localhost in dev/test context is often fine
            if grep -qE "(development|testing|test server|local dev|127\.0\.0\.1.*test)" <<< "$output"; then
                return 0
            fi
            ;;
        "CRYPTO")
            # MD5/SHA1 for non-security purposes (checksums, cache keys)
            if grep -qE "(checksum|cache.?key|file.?hash|etag|content.?hash|fingerprint)" <<< "$output"; then
                return 0
            fi
            ;;
    esac

    return 1
}

check_security() {
    local output="$1"
    local violations=0

    # === SQL Injection ===
    local sql_patterns=(
        "SELECT.*FROM.*WHERE.*=.*\\\$"           # Unparameterized queries
        "INSERT INTO.*VALUES.*\\\$"              # Direct variable insertion
        "UPDATE.*SET.*=.*\\\$"                   # Direct variable in UPDATE
        "DELETE FROM.*WHERE.*\\\$"               # Direct variable in DELETE
        '"\s*\+\s*.*\s*\+\s*".*SELECT'          # String concat with SELECT
        "'\s*\+\s*.*\s*\+\s*'.*SELECT"          # String concat with SELECT
        'f".*SELECT.*{.*}"'                      # Python f-string SQL
        'f".*INSERT.*{.*}"'                      # Python f-string SQL
        '`.*SELECT.*\\\$\{.*\}`'                 # JS template literal SQL
        "execute\s*\(\s*[\"'].*%s"              # Python % formatting in SQL
        "query\s*\(\s*[\"'].*\\\$"              # Direct variable in query
    )

    for pattern in "${sql_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "SQLi"; then
                echo "‚ö†Ô∏è SECURITY [SQLi]: Potential SQL injection - use parameterized queries" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    # === XSS (Cross-Site Scripting) ===
    local xss_patterns=(
        "innerHTML\s*=\s*"                       # Direct innerHTML assignment
        "outerHTML\s*=\s*"                       # Direct outerHTML assignment
        "document\.write\s*\("                   # document.write
        "\.html\s*\(\s*[^)]*\\\$"               # jQuery .html() with variable
        "dangerouslySetInnerHTML"                # React dangerous prop
        "v-html\s*="                             # Vue v-html directive
        "\[innerHTML\]\s*="                      # Angular innerHTML binding
        "<%=.*%>"                                # Unescaped ERB
        "\{\{.*\|.*safe.*\}\}"                   # Django/Jinja safe filter
        "Markup\s*\("                            # Flask Markup
        "render_template_string"                 # Flask template injection
    )

    for pattern in "${xss_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "XSS"; then
                echo "‚ö†Ô∏è SECURITY [XSS]: Potential XSS vulnerability - sanitize output" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    # === Command Injection ===
    local cmd_patterns=(
        "os\.system\s*\("                        # Python os.system
        "subprocess\.call\s*\(.*shell\s*=\s*True" # Python subprocess with shell
        "subprocess\.run\s*\(.*shell\s*=\s*True"  # Python subprocess with shell
        "exec\s*\(\s*\\\$"                       # PHP/bash exec with variable
        "shell_exec\s*\("                        # PHP shell_exec
        "passthru\s*\("                          # PHP passthru
        "system\s*\(\s*\\\$"                     # system() with variable
        "popen\s*\(\s*\\\$"                      # popen with variable
        "eval\s*\(\s*\\\$"                       # eval with variable
        '`\s*\\\$'                               # Backtick with variable
        "\|\s*bash"                              # Pipe to bash
        "child_process\.exec\s*\("               # Node child_process.exec
        "spawn\s*\(.*\{.*shell.*\}"              # Node spawn with shell
    )

    for pattern in "${cmd_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "CMDi"; then
                echo "‚ö†Ô∏è SECURITY [CMDi]: Potential command injection - avoid shell=True, sanitize input" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    # === Path Traversal / LFI / RFI ===
    local path_patterns=(
        "open\s*\(\s*\\\$"                       # open() with variable
        "file_get_contents\s*\(\s*\\\$"          # PHP file_get_contents
        "include\s*\(\s*\\\$"                    # PHP include with variable
        "require\s*\(\s*\\\$"                    # PHP require with variable
        "readFile\s*\(\s*\\\$"                   # Node readFile with variable
        "\.\./"                                  # Path traversal sequence
        "\.\.%2[fF]"                             # URL encoded traversal
        "php://input"                            # PHP input wrapper
        "php://filter"                           # PHP filter wrapper
        "file://"                                # File protocol
        "expect://"                              # Expect wrapper
        "data://"                                # Data protocol in file context
    )

    for pattern in "${path_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "LFI"; then
                echo "‚ö†Ô∏è SECURITY [LFI/RFI]: Potential path traversal - validate and sanitize paths" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    # === Hardcoded Secrets ===
    local secret_patterns=(
        "password\s*=\s*['\"][^'\"]{4,}['\"]"    # Hardcoded password
        "api_key\s*=\s*['\"][^'\"]{8,}['\"]"     # Hardcoded API key
        "secret\s*=\s*['\"][^'\"]{8,}['\"]"      # Hardcoded secret
        "token\s*=\s*['\"][^'\"]{8,}['\"]"       # Hardcoded token
        "AWS_SECRET_ACCESS_KEY"                  # AWS secret
        "PRIVATE_KEY.*BEGIN"                     # Private key
        "sk-[a-zA-Z0-9]{20,}"                    # OpenAI API key pattern
        "ghp_[a-zA-Z0-9]{36}"                    # GitHub token pattern
        "xox[baprs]-[a-zA-Z0-9]+"                # Slack token pattern
        "-----BEGIN RSA PRIVATE KEY-----"        # RSA private key
        "-----BEGIN OPENSSH PRIVATE KEY-----"    # OpenSSH private key
    )

    for pattern in "${secret_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "SECRETS"; then
                echo "‚ö†Ô∏è SECURITY [SECRETS]: Hardcoded secret detected - use environment variables" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    # === SSRF (Server-Side Request Forgery) ===
    local ssrf_patterns=(
        "requests\.get\s*\(\s*\\\$"              # Python requests with variable URL
        "urllib\.request\.urlopen\s*\(\s*\\\$"  # Python urllib with variable
        "curl_exec\s*\("                         # PHP curl
        "file_get_contents\s*\(\s*[\"']http"    # PHP remote file
        "fetch\s*\(\s*\\\$"                      # JS fetch with variable
        "axios\.\w+\s*\(\s*\\\$"                 # Axios with variable URL
        "http\.get\s*\(\s*\\\$"                  # Node http with variable
        "localhost"                              # Localhost access
        "127\.0\.0\.1"                           # Localhost IP
        "0\.0\.0\.0"                             # Any interface
        "169\.254\."                             # AWS metadata
        "metadata\.google"                       # GCP metadata
    )

    for pattern in "${ssrf_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "SSRF"; then
                echo "‚ö†Ô∏è SECURITY [SSRF]: Potential SSRF - validate and whitelist URLs" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    # === Insecure Deserialization ===
    local deser_patterns=(
        "pickle\.loads\s*\("                     # Python pickle
        "yaml\.load\s*\([^)]*Loader\s*="         # PyYAML unsafe load
        "yaml\.unsafe_load"                      # PyYAML unsafe
        "unserialize\s*\("                       # PHP unserialize
        "Marshal\.load"                          # Ruby Marshal
        "ObjectInputStream"                      # Java deserialization
        "readObject\s*\("                        # Java readObject
        "JSON\.parse.*eval"                      # JS JSON with eval
    )

    for pattern in "${deser_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "DESER"; then
                echo "‚ö†Ô∏è SECURITY [DESER]: Insecure deserialization - use safe loaders" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    # === XXE (XML External Entity) ===
    local xxe_patterns=(
        "<!ENTITY"                               # XML entity declaration
        "SYSTEM\s*[\"']file:"                    # External file entity
        "SYSTEM\s*[\"']http:"                    # External HTTP entity
        "etree\.parse\s*\("                      # Python lxml parse
        "XMLParser\s*\("                         # Python XMLParser
        "parseXML\s*\("                          # Generic XML parsing
        "DocumentBuilder"                        # Java XML parsing
        "SAXParser"                              # Java SAX
    )

    for pattern in "${xxe_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "XXE"; then
                echo "‚ö†Ô∏è SECURITY [XXE]: Potential XXE - disable external entities" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    # === Dangerous Commands ===
    local danger_patterns=(
        "rm -rf /"                               # Recursive root delete
        "rm -rf /\*"                             # Root wildcard delete
        "chmod 777"                              # World-writable permissions
        "chmod -R 777"                           # Recursive world-writable
        "> /dev/sd"                              # Write to disk device
        "mkfs\."                                 # Format filesystem
        "dd if=.*/dev/"                          # Raw disk operations
        ":(){.*:.*};:"                           # Fork bomb
        "wget.*\|\s*bash"                        # Download and execute
        "curl.*\|\s*bash"                        # Download and execute
        "curl.*\|\s*sh"                          # Download and execute
    )

    for pattern in "${danger_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            # Dangerous commands don't get false positive bypass - always flag
            echo "‚ö†Ô∏è SECURITY [DANGER]: Dangerous command detected: $pattern" >> "$VIOLATIONS_FILE"
            ((violations++))
            break
        fi
    done

    # === Weak Cryptography ===
    local crypto_patterns=(
        "md5\s*\("                               # MD5 hashing
        "sha1\s*\("                              # SHA1 hashing
        "DES\s*\("                               # DES encryption
        "ECB"                                    # ECB mode
        "random\.random\s*\("                    # Insecure random (Python)
        "Math\.random\s*\("                      # Insecure random (JS)
        "rand\s*\(\s*\)"                         # Insecure random (PHP/C)
        "password.*plaintext"                    # Plaintext password storage
    )

    for pattern in "${crypto_patterns[@]}"; do
        if grep -qiE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "CRYPTO"; then
                echo "‚ö†Ô∏è SECURITY [CRYPTO]: Weak cryptography - use strong algorithms" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    [ "$violations" -gt 0 ] && return 1 || return 0
}

# ============================================================================
# CLAUDE.MD GENERATION
# ============================================================================

generate_claude_md() {
    local target_file="$1"

    cat > "$target_file" << 'CLAUDE_MD_EOF'
# CLAUDE.md - Project Rules

## Anti-Slop Rules
- NO greeting phrases: "I'd be happy to", "Let me", "Here's", "Great question"
- NO preamble - start directly with code or action
- NO filler words or excessive explanation
- Be terse and direct

## Code Quality
- NO placeholders: TODO, TBD, FIXME, pass, stub, unimplemented!
- NO incomplete implementations
- Every function must be fully implemented
- Include error handling

## Testing Requirements
- Include tests with every code change
- Tests must pass before considering work complete

## Workflow
- Use patch/edit mode for existing files
- One feature at a time
- Commit after completing each feature

## Security
- No hardcoded secrets or API keys
- Validate all user input
- Use parameterized queries for databases
CLAUDE_MD_EOF
}

run_interactive_mode() {
    local claude_md="$WORK_DIR/CLAUDE.md"

    if [ ! -f "$claude_md" ]; then
        echo -e "${CYAN}üìù Creating CLAUDE.md with enforcement rules...${NC}"
        generate_claude_md "$claude_md"
        echo -e "${GREEN}‚úÖ Created CLAUDE.md${NC}"
    fi

    exec "$CLAUDE_REAL" "$@"
}

run_raw_mode() {
    if [ -n "$TASK_ARGS" ]; then
        exec "$CLAUDE_REAL" $TASK_ARGS
    else
        exec "$CLAUDE_REAL"
    fi
}

# ============================================================================
# SESSION MODE DETECTION
# ============================================================================

detect_session_mode() {
    if [ ! -f "$PROGRESS_FILE" ]; then
        echo "initializer"
    else
        echo "continuing"
    fi
}

get_session_number() {
    local count=0
    if [ -f "$PROGRESS_FILE" ]; then
        count=$(grep -c "## Session" "$PROGRESS_FILE" 2>/dev/null || echo 0)
    fi
    echo "$count"
}

# ============================================================================
# GOLDEN TICKETS (BYPASS FOR HELP/EXPLAIN)
# ============================================================================

check_golden_ticket() {
    local input="$1"

    local patterns=(
        "^explain"
        "^what is"
        "^how does"
        "^why does"
        "^help$"
        "^status$"
    )

    for pattern in "${patterns[@]}"; do
        if grep -qiE "$pattern" <<< "$input"; then
            return 0
        fi
    done

    return 1
}

# ============================================================================
# ENFORCEMENT FUNCTIONS
# ============================================================================

enforce_no_slop() {
    local output="$1"
    local violations=0

    local patterns=(
        "I'd be happy to"
        "I'll help you"
        "Let me"
        "Let's"
        "Here's"
        "Here is"
        "Great question"
        "I understand"
        "I can help"
        "I will"
        "I've created"
        "I've made"
    )

    for p in "${patterns[@]}"; do
        if grep -qi "$p" <<< "$output"; then
            echo "‚ùå SLOP: '$p'" >> "$VIOLATIONS_FILE"
            ((violations++))
        fi
    done

    [ "$violations" -gt 0 ] && return 1 || return 0
}

enforce_no_placeholders() {
    local output="$1"
    local violations=0

    local patterns=(
        "TODO"
        "TBD"
        "FIXME"
        "# TODO: pass"
        "unimplemented!"
        "todo!"
        "NotImplementedError"
    )

    for p in "${patterns[@]}"; do
        if grep -qE "$p" <<< "$output"; then
            echo "‚ùå PLACEHOLDER: '$p'" >> "$VIOLATIONS_FILE"
            ((violations++))
        fi
    done

    [ "$violations" -gt 0 ] && return 1 || return 0
}

enforce_harness_compliance() {
    local output="$1"
    local mode="$2"
    local violations=0

    if [ "$mode" = "continuing" ]; then
        if ! grep -qiE "(session|progress|feature|complete|implement)" <<< "$output"; then
            echo "‚ùå HARNESS: Did not acknowledge progress file" >> "$VIOLATIONS_FILE"
            ((violations++))
        fi
    elif [ "$mode" = "initializer" ]; then
        if ! grep -qE "(claude-progress.txt|features.json)" <<< "$output"; then
            echo "‚ùå HARNESS: Did not create harness files" >> "$VIOLATIONS_FILE"
            ((violations++))
        fi
    fi

    [ "$violations" -gt 0 ] && return 1 || return 0
}

# ============================================================================
# HARNESS PROMPTS
# ============================================================================

build_initializer_prompt() {
    local task="$1"
    cat << 'EOF'
You are starting a NEW PROJECT. This is the FIRST session.

MANDATORY SEQUENCE:
1. Create claude-progress.txt with project header
2. Create features.json listing ALL features needed
3. Create init.sh for dev environment setup
4. Implement exactly ONE feature
5. Update progress file
6. Commit your work

RULES:
- Work on ONLY ONE feature this session
- Include tests for the feature
- No placeholders (TODO, pass, stub)
EOF
    echo ""
    echo "Task: $task"
}

build_continuing_prompt() {
    local task="$1"
    local session_num="$2"
    local display_num=$((session_num + 1))

    cat << EOF
You are CONTINUING an existing project. Session #${display_num}.

STARTUP SEQUENCE:
1. Read claude-progress.txt - show last entries
2. Check git log -5
3. Read features.json - pick ONE with "passes": false
4. State which feature you will work on

RULES:
- Work on EXACTLY ONE feature
- Include tests
- Update progress when done
- Commit with descriptive message
- No placeholders

Task: $task
EOF
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

run_harness() {
    local enforced_prompt="$1"
    local session_mode="$2"

    local MAX_RETRIES=3
    local retry_count=0
    local success=0

    > "$VIOLATIONS_FILE"

    while [ "$retry_count" -lt "$MAX_RETRIES" ]; do
        echo -e "${CYAN}üöÄ Attempt $((retry_count + 1))/$MAX_RETRIES${NC}"

        "$CLAUDE_REAL" --dangerously-skip-permissions -p "$enforced_prompt" 2>&1 | tee "$OUTPUT_FILE"
        local OUTPUT
        OUTPUT="$(cat "$OUTPUT_FILE")"

        > "$VIOLATIONS_FILE"

        # Run all checks
        enforce_no_slop "$OUTPUT" || true
        enforce_no_placeholders "$OUTPUT" || true
        enforce_harness_compliance "$OUTPUT" "$session_mode" || true
        check_security "$OUTPUT" || true

        if [ ! -s "$VIOLATIONS_FILE" ]; then
            echo -e "${GREEN}‚úÖ All checks passed${NC}"
            success=1
            break
        fi

        echo -e "${RED}‚ùå Violations detected:${NC}"
        cat "$VIOLATIONS_FILE"

        retry_count=$((retry_count + 1))

        if [ "$retry_count" -lt "$MAX_RETRIES" ]; then
            echo -e "${YELLOW}Retrying with violation feedback...${NC}"
            enforced_prompt="VIOLATIONS DETECTED - Please fix:
$(cat "$VIOLATIONS_FILE")

$enforced_prompt"
        fi
    done

    if [ "$success" -eq 0 ]; then
        echo -e "${RED}‚ö†Ô∏è Max retries reached with violations${NC}"
        echo -e "${YELLOW}Use 'claude --rollback' to restore previous state${NC}"
    fi
}

# Parse arguments
parse_arguments "$@"

# Raw mode
if [ "$RAW_MODE" = "true" ]; then
    run_raw_mode
fi

# Interactive mode
if [ "$INTERACTIVE_MODE" = "true" ]; then
    run_interactive_mode
fi

# Harness mode - prompt for task if needed
if [ "$HARNESS_MODE" = "true" ] && [ -z "$TASK_ARGS" ]; then
    echo -e "${CYAN}Enter your task:${NC}"
    read -r TASK_ARGS
    if [ -z "$TASK_ARGS" ]; then
        echo -e "${RED}No task provided.${NC}"
        exit 1
    fi
fi

# Default to harness mode if args given
if [ -z "$HARNESS_MODE" ] && [ -n "$TASK_ARGS" ]; then
    HARNESS_MODE="true"
fi

if [ -z "$HARNESS_MODE" ]; then
    run_interactive_mode
fi

# Detect session
SESSION_MODE="$(detect_session_mode)"
SESSION_NUM="$(get_session_number)"
DISPLAY_SESSION=$((SESSION_NUM + 1))

# Header
echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
echo -e "${CYAN}‚ïë${NC}  ${MAGENTA}üîê CLAUDE HARNESS${NC}                                        ${CYAN}‚ïë${NC}"
echo -e "${CYAN}‚ïë${NC}  ${YELLOW}Mode: ${SESSION_MODE^^} | Session #${DISPLAY_SESSION}${NC}                       ${CYAN}‚ïë${NC}"
echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"

# Take snapshot BEFORE any changes
SNAPSHOT_ID="$(take_snapshot)"
echo -e "${GREEN}üì∏ Snapshot saved: $SNAPSHOT_ID${NC}"
echo -e "${CYAN}   Use 'claude --rollback' to restore if needed${NC}"

# Golden ticket check
if check_golden_ticket "$TASK_ARGS"; then
    echo -e "${YELLOW}üé´ Help/explain request - running directly${NC}"
    "$CLAUDE_REAL" --dangerously-skip-permissions -p "$TASK_ARGS" 2>&1
    exit 0
fi

# Build prompt
if [ "$SESSION_MODE" = "initializer" ]; then
    ENFORCED_PROMPT="$(build_initializer_prompt "$TASK_ARGS")"
else
    ENFORCED_PROMPT="$(build_continuing_prompt "$TASK_ARGS" "$SESSION_NUM")"
fi

# Add enforcement rules
ENFORCED_PROMPT="$ENFORCED_PROMPT

ENFORCEMENT:
- NO SLOP: No greetings or preambles
- NO PLACEHOLDERS: No TODO, pass, stub
- TESTS REQUIRED: Include tests
- SECURITY: No hardcoded secrets

Start DIRECTLY with action/code."

# Load CLAUDE.md if present
if [ -f "CLAUDE.md" ]; then
    CLAUDE_RULES="$(head -50 CLAUDE.md 2>/dev/null || echo "")"
    ENFORCED_PROMPT="$ENFORCED_PROMPT

Project rules:
$CLAUDE_RULES"
fi

echo ""
run_harness "$ENFORCED_PROMPT" "$SESSION_MODE"

# Post-session status
echo ""
echo -e "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
echo -e "${CYAN}üìä Session Summary${NC}"
echo -e "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"

if [ -f "$FEATURES_FILE" ] && command -v jq >/dev/null 2>&1; then
    PENDING=$(jq '[.features[] | select(.passes == false)] | length' "$FEATURES_FILE" 2>/dev/null || echo "?")
    DONE=$(jq '[.features[] | select(.passes == true)] | length' "$FEATURES_FILE" 2>/dev/null || echo "?")
    echo -e "${CYAN}Features: ${GREEN}$DONE done${NC} / ${YELLOW}$PENDING pending${NC}"
fi

if git status --porcelain 2>/dev/null | grep -q .; then
    echo -e "${YELLOW}üìù Uncommitted changes - review and commit${NC}"
else
    echo -e "${GREEN}‚úÖ Working tree clean${NC}"
fi

echo -e "${CYAN}Snapshot: $SNAPSHOT_ID (use --rollback to restore)${NC}"
