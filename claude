#!/bin/bash
# Claude Harness - Quality Enforcement for Claude CLI
# Implements code quality gates and session tracking
#
# Usage:
#   claude                    - Interactive mode (auto-creates CLAUDE.md)
#   claude "Build X"          - Full harness mode with enforcement
#   claude --harness          - Force harness mode
#   claude --raw [args]       - Bypass harness, run Claude directly

set -euo pipefail

# =========================================================================
# CONFIGURATION
# =========================================================================

# Find the real Claude binary
if [ -x "$HOME/.local/bin/claude.real" ]; then
    CLAUDE_REAL="$HOME/.local/bin/claude.real"
elif [ -d "$HOME/.local/share/claude/versions" ]; then
    CLAUDE_REAL=$(ls -t "$HOME/.local/share/claude/versions"/* 2>/dev/null | head -1)
else
    echo "ERROR: Cannot find Claude binary" >&2
    echo "Install Claude CLI first, then rename it to claude.real" >&2
    exit 1
fi

# ============================================================================
# ARGUMENT PARSING
# ============================================================================

HARNESS_MODE=""
RAW_MODE=""
INTERACTIVE_MODE=""
AUTO_MODE=""
TASK_ARGS=""

show_help() {
    cat << 'EOF'
Claude Harness - Quality Enforcement

USAGE:
  claude                    Interactive mode (creates CLAUDE.md if needed)
  claude "task description" Full harness mode with enforcement
  claude "task" --auto      Auto-continue until all features complete
  claude --harness          Force harness mode
  claude --raw [args]       Bypass harness, run Claude directly
  claude --rollback         Restore last snapshot
  claude --metrics          Show session metrics
  claude --context          Load saved project context

FLAGS:
  --raw         Bypass all harness logic
  --harness     Force harness mode
  --auto        Auto-continue sessions until project complete
  --rollback    Restore previous snapshot
  --metrics     Show session metrics and violation history
  --context     Load saved project context
  -h, --help    Show this help

ENFORCEMENT:
  - No slop (greeting phrases, filler)
  - No placeholders (TODO, FIXME, pass, stub)
  - Security checks (OWASP top 10)
  - Session tracking (initializer/continuing modes)
  - Git snapshots before changes

QUALITY HINTS (non-blocking):
  - Code complexity warnings
  - Test coverage reminders
  - Performance anti-patterns
EOF
}

parse_arguments() {
    if [ $# -eq 0 ]; then
        INTERACTIVE_MODE="true"
        return
    fi

    # Parse flags - handle --auto anywhere in args
    local args_without_auto=()
    while [ $# -gt 0 ]; do
        case "$1" in
            --auto)
                AUTO_MODE="true"
                shift
                ;;
            --raw)
                RAW_MODE="true"
                shift
                TASK_ARGS="$*"
                return
                ;;
            --harness)
                HARNESS_MODE="true"
                shift
                ;;
            --rollback)
                do_rollback
                exit 0
                ;;
            --metrics)
                show_metrics
                exit 0
                ;;
            --context)
                load_context
                exit 0
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                args_without_auto+=("$1")
                shift
                ;;
        esac
    done

    # Reconstruct task args without --auto
    if [ ${#args_without_auto[@]} -gt 0 ]; then
        HARNESS_MODE="true"
        TASK_ARGS="${args_without_auto[*]}"
    fi
}

# ============================================================================
# GLOBALS
# ============================================================================

WORK_DIR="$(pwd)"
SESSION_ID="$(date +%s)-$$"
SESSION_DIR="/tmp/claude-$SESSION_ID"
SNAPSHOT_DIR="$HOME/.claude/snapshots"
VIOLATIONS_LOG="$HOME/.claude/violations.log"
METRICS_FILE="$HOME/.claude/metrics.json"
CONTEXT_CACHE="$HOME/.claude/context_cache"

PROGRESS_FILE="$WORK_DIR/claude-progress.txt"
FEATURES_FILE="$WORK_DIR/features.json"

OUTPUT_FILE="$SESSION_DIR/output.txt"
VIOLATIONS_FILE="$SESSION_DIR/violations.txt"
COMPLEXITY_FILE="$SESSION_DIR/complexity.txt"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

mkdir -p "$SESSION_DIR" "$SNAPSHOT_DIR" "$CONTEXT_CACHE"
trap 'rm -rf "$SESSION_DIR"' EXIT

# ============================================================================
# SNAPSHOT SYSTEM (ROLLBACK SAFETY)
# ============================================================================

take_snapshot() {
    local snap_id="snap-$SESSION_ID"
    local snap_path="$SNAPSHOT_DIR/$snap_id"

    if git rev-parse --git-dir >/dev/null 2>&1; then
        git stash push -m "claude-harness-$snap_id" --include-untracked 2>/dev/null || true
        git rev-parse HEAD > "$snap_path.commit" 2>/dev/null || true
        git stash pop 2>/dev/null || true

        # Also save diff for non-stash rollback
        git diff HEAD > "$snap_path.diff" 2>/dev/null || true
        git status --porcelain > "$snap_path.status" 2>/dev/null || true
    fi

    # Save file hashes for verification
    find . -type f \( -name "*.py" -o -name "*.js" -o -name "*.ts" -o -name "*.rs" -o -name "*.go" \) 2>/dev/null | \
        head -100 | while IFS= read -r f; do
            sha256sum "$f" 2>/dev/null || true
        done > "$snap_path.hashes"

    # Remember last snapshot
    echo "$snap_id" > "$SNAPSHOT_DIR/latest"

    echo "$snap_id"
}

do_rollback() {
    if [ ! -f "$SNAPSHOT_DIR/latest" ]; then
        echo -e "${RED}No snapshot available to rollback${NC}"
        exit 1
    fi

    local snap_id=$(cat "$SNAPSHOT_DIR/latest")
    local snap_path="$SNAPSHOT_DIR/$snap_id"

    echo -e "${YELLOW}Rolling back to snapshot: $snap_id${NC}"

    if [ -f "$snap_path.commit" ] && git rev-parse --git-dir >/dev/null 2>&1; then
        local commit=$(cat "$snap_path.commit")
        echo -e "${CYAN}Resetting to commit: $commit${NC}"
        git reset --hard "$commit" 2>/dev/null || true

        if [ -f "$snap_path.diff" ] && [ -s "$snap_path.diff" ]; then
            echo -e "${CYAN}Applying saved changes...${NC}"
            git apply "$snap_path.diff" 2>/dev/null || true
        fi
    fi

    echo -e "${GREEN}‚úÖ Rollback complete${NC}"
}

# ============================================================================
# METRICS TRACKING
# ============================================================================

init_metrics() {
    if [ ! -f "$METRICS_FILE" ]; then
        cat > "$METRICS_FILE" << 'EOF'
{
    "total_sessions": 0,
    "total_violations": 0,
    "violations_by_type": {},
    "success_rate": 0,
    "avg_retries": 0,
    "last_session": null,
    "projects": {}
}
EOF
    fi
}

update_metrics() {
    local violation_count="$1"
    local retry_count="$2"
    local success="$3"
    local project_name
    project_name=$(basename "$WORK_DIR")

    init_metrics

    if command -v jq >/dev/null 2>&1; then
        local tmp_file="/tmp/metrics_update_$$.json"
        jq --arg proj "$project_name" \
           --arg date "$(date -Iseconds)" \
           --argjson violations "$violation_count" \
           --argjson retries "$retry_count" \
           --argjson success "$success" \
           '.total_sessions += 1 |
            .total_violations += $violations |
            .last_session = $date |
            .projects[$proj] = (.projects[$proj] // {sessions: 0, violations: 0}) |
            .projects[$proj].sessions += 1 |
            .projects[$proj].violations += $violations |
            .projects[$proj].last_used = $date' \
           "$METRICS_FILE" > "$tmp_file" && mv "$tmp_file" "$METRICS_FILE"
    fi
}

show_metrics() {
    init_metrics
    if command -v jq >/dev/null 2>&1 && [ -f "$METRICS_FILE" ]; then
        echo -e "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
        echo -e "${CYAN}üìä Harness Metrics${NC}"
        echo -e "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
        local sessions violations
        sessions=$(jq '.total_sessions' "$METRICS_FILE")
        violations=$(jq '.total_violations' "$METRICS_FILE")
        echo -e "Total Sessions: ${GREEN}$sessions${NC}"
        echo -e "Total Violations: ${YELLOW}$violations${NC}"
        if [ "$sessions" -gt 0 ]; then
            local avg
            avg=$(echo "scale=2; $violations / $sessions" | bc 2>/dev/null || echo "N/A")
            echo -e "Avg Violations/Session: ${CYAN}$avg${NC}"
        fi
        echo ""
        echo -e "${CYAN}Projects:${NC}"
        jq -r '.projects | to_entries[] | "  \(.key): \(.value.sessions) sessions, \(.value.violations) violations"' "$METRICS_FILE" 2>/dev/null || true
    else
        echo -e "${YELLOW}No metrics data available (jq required)${NC}"
    fi
}

# ============================================================================
# CODE COMPLEXITY ANALYSIS
# ============================================================================

check_complexity() {
    local output="$1"
    local warnings=0

    # Check for deeply nested code (4+ levels)
    if grep -qE "^(\s{16,}|\t{4,})" <<< "$output"; then
        echo "‚ö†Ô∏è COMPLEXITY: Deep nesting detected (4+ levels) - consider refactoring" >> "$COMPLEXITY_FILE"
        ((warnings++))
    fi

    # Check for very long functions (50+ lines of code in a single block)
    local consecutive_code=0
    while IFS= read -r line; do
        if [[ "$line" =~ ^[[:space:]]*[^#/\*[:space:]] ]]; then
            ((consecutive_code++))
            if [ "$consecutive_code" -gt 50 ]; then
                echo "‚ö†Ô∏è COMPLEXITY: Long function detected (50+ lines) - consider splitting" >> "$COMPLEXITY_FILE"
                ((warnings++))
                break
            fi
        else
            consecutive_code=0
        fi
    done <<< "$output"

    # Check for many parameters (6+)
    if grep -qE "def \w+\([^)]{100,}\)|function \w+\([^)]{100,}\)" <<< "$output"; then
        echo "‚ö†Ô∏è COMPLEXITY: Function with many parameters - consider using object/struct" >> "$COMPLEXITY_FILE"
        ((warnings++))
    fi

    [ "$warnings" -gt 0 ] && return 1 || return 0
}

# ============================================================================
# TEST COVERAGE HINTS
# ============================================================================

check_test_coverage() {
    local output="$1"
    local hints=0

    # Check if code has corresponding tests
    if grep -qE "(def |function |class |fn )" <<< "$output"; then
        if ! grep -qiE "(test_|_test|\.test\.|spec\.|describe\(|it\(|#\[test\]|@Test)" <<< "$output"; then
            echo "üí° COVERAGE: New code detected but no tests included" >> "$COMPLEXITY_FILE"
            ((hints++))
        fi
    fi

    # Check for error handling without tests
    if grep -qE "(try|catch|except|raise|throw|Error|Exception)" <<< "$output"; then
        if ! grep -qiE "(test.*error|test.*exception|should.*throw|expect.*error)" <<< "$output"; then
            echo "üí° COVERAGE: Error handling added - consider adding error case tests" >> "$COMPLEXITY_FILE"
            ((hints++))
        fi
    fi

    # Check for edge cases
    if grep -qE "(if.*==.*0|if.*null|if.*None|if.*empty|\.length.*==.*0)" <<< "$output"; then
        echo "üí° COVERAGE: Edge case handling detected - ensure tests cover these" >> "$COMPLEXITY_FILE"
        ((hints++))
    fi

    [ "$hints" -gt 0 ] && return 1 || return 0
}

# ============================================================================
# PERFORMANCE HINTS
# ============================================================================

check_performance() {
    local output="$1"
    local hints=0

    # N+1 query pattern
    if grep -qE "for.*in.*:.*\.query\(|\.forEach.*fetch|\.map.*await" <<< "$output"; then
        echo "‚ö° PERF: Potential N+1 query pattern - consider batch fetching" >> "$COMPLEXITY_FILE"
        ((hints++))
    fi

    # Synchronous file I/O in async context
    if grep -qE "async.*readFileSync|async.*writeFileSync" <<< "$output"; then
        echo "‚ö° PERF: Sync file I/O in async context - use async versions" >> "$COMPLEXITY_FILE"
        ((hints++))
    fi

    # Large array operations without streaming
    if grep -qE "\.readFile.*JSON\.parse|read.*entire.*file" <<< "$output"; then
        echo "‚ö° PERF: Reading entire file into memory - consider streaming for large files" >> "$COMPLEXITY_FILE"
        ((hints++))
    fi

    # Regex in loops
    if grep -qE "for.*re\.|while.*regex|\.forEach.*match\(" <<< "$output"; then
        echo "‚ö° PERF: Regex in loop - consider compiling regex outside loop" >> "$COMPLEXITY_FILE"
        ((hints++))
    fi

    # String concatenation in loops
    if grep -qE "for.*\+=.*\"|while.*\+=.*'" <<< "$output"; then
        echo "‚ö° PERF: String concatenation in loop - consider using join/builder" >> "$COMPLEXITY_FILE"
        ((hints++))
    fi

    [ "$hints" -gt 0 ] && return 1 || return 0
}

# ============================================================================
# CONTEXT MANAGEMENT
# ============================================================================

save_context() {
    local project_name
    project_name=$(basename "$WORK_DIR")
    local context_file="$CONTEXT_CACHE/${project_name}_context.txt"

    # Save current context summary
    {
        echo "=== Context saved: $(date) ==="
        echo "Project: $project_name"
        echo "Working Dir: $WORK_DIR"

        if [ -f "$PROGRESS_FILE" ]; then
            echo ""
            echo "=== Last Progress ==="
            tail -30 "$PROGRESS_FILE"
        fi

        if [ -f "$FEATURES_FILE" ] && command -v jq >/dev/null 2>&1; then
            echo ""
            echo "=== Features Status ==="
            jq -r '.features[] | "\(.id): \(if .passes then "‚úÖ" else "‚è≥" end) \(.description)"' "$FEATURES_FILE" 2>/dev/null || true
        fi

        if git rev-parse --git-dir >/dev/null 2>&1; then
            echo ""
            echo "=== Recent Commits ==="
            git log --oneline -5 2>/dev/null || true
        fi
    } > "$context_file"
}

load_context() {
    local project_name
    project_name=$(basename "$WORK_DIR")
    local context_file="$CONTEXT_CACHE/${project_name}_context.txt"

    if [ -f "$context_file" ]; then
        echo -e "${CYAN}üìö Loading previous context...${NC}"
        cat "$context_file"
        echo ""
    else
        echo -e "${YELLOW}No saved context for this project${NC}"
    fi
}

# ============================================================================
# OUTPUT PREFILL ENFORCEMENT
# ============================================================================

build_prefill_instruction() {
    cat << 'EOF'
RESPONSE FORMAT - You MUST start your response with ONE of these exact prefixes:
- "```" (if providing code)
- "Modified " (if editing a file)
- "Created " (if creating a file)
- "Fixed " (if fixing a bug)
- "Added " (if adding a feature)
- "Removed " (if removing code)
- "Updated " (if updating existing code)
- "Tested " (if running tests)
- "Error: " (if encountering an error)

DO NOT start with greetings, explanations, or meta-commentary.
Start DIRECTLY with the action.
EOF
}

# ============================================================================
# SECURITY CHECKS
# ============================================================================

# False positive contexts - these patterns indicate safe/educational usage
is_false_positive() {
    local output="$1"
    local category="$2"

    # Check for documentation/comment context
    if grep -qE "(#.*example|//.*example|/\*.*example|\*.*example|>>>|docstring|documentation|tutorial|README|\.md:|test_|_test\.py|spec\.js|\.spec\.ts)" <<< "$output"; then
        return 0
    fi

    # Check for safe alternatives being shown
    case "$category" in
        "SQLi")
            # Safe if using parameterized queries nearby
            if grep -qE "(parameterized|prepared statement|\?.*%s.*execute|cursor\.execute.*,\s*\(|\.query\(.*,\s*\[)" <<< "$output"; then
                return 0
            fi
            ;;
        "XSS")
            # Safe if using sanitization
            if grep -qE "(sanitize|escape|encode|DOMPurify|textContent|createTextNode)" <<< "$output"; then
                return 0
            fi
            ;;
        "CMDi")
            # Safe if using safe alternatives
            if grep -qE "(shlex\.quote|subprocess\.run\(\[|shell=False|execFile)" <<< "$output"; then
                return 0
            fi
            ;;
        "LFI")
            # Safe if path validation/sanitization present
            if grep -qE "(os\.path\.basename|realpath|abspath|path\.resolve|sanitize.?path|validate.?path|whitelist|allowed.?paths)" <<< "$output"; then
                return 0
            fi
            # Relative paths in safe contexts (imports, requires)
            if grep -qE "(from \.\.|import \.\.|require\('\.\./)" <<< "$output"; then
                return 0
            fi
            ;;
        "SECRETS")
            # Safe if using environment variables or secret managers
            if grep -qE "(os\.environ|process\.env|getenv|secret.?manager|vault|\.env|config\[|settings\.|from_env)" <<< "$output"; then
                return 0
            fi
            # Example/placeholder secrets
            if grep -qE "(example|placeholder|your.?key.?here|xxx|changeme|TODO)" <<< "$output"; then
                return 0
            fi
            ;;
        "SSRF")
            # localhost in dev/test context is often fine
            if grep -qE "(development|testing|test server|local dev|127\.0\.0\.1.*test)" <<< "$output"; then
                return 0
            fi
            # URL validation present
            if grep -qE "(validate.?url|whitelist|allowed.?hosts|url.?validator)" <<< "$output"; then
                return 0
            fi
            ;;
        "DESER")
            # Safe if using safe loaders
            if grep -qE "(safe_load|SafeLoader|json\.loads|JSON\.parse[^(]*\(|trusted.?data)" <<< "$output"; then
                return 0
            fi
            ;;
        "XXE")
            # Safe if external entities disabled
            if grep -qE "(defusedxml|resolve_entities\s*=\s*False|FEATURE_SECURE|disable.?external|no.?entity)" <<< "$output"; then
                return 0
            fi
            ;;
        "CRYPTO")
            # MD5/SHA1 for non-security purposes (checksums, cache keys)
            if grep -qE "(checksum|cache.?key|file.?hash|etag|content.?hash|fingerprint|non.?crypto)" <<< "$output"; then
                return 0
            fi
            ;;
    esac

    return 1
}

check_security() {
    local output="$1"
    local violations=0

    # === SQL Injection ===
    local sql_patterns=(
        "SELECT.*FROM.*WHERE.*=.*\\\$"           # Unparameterized queries
        "INSERT INTO.*VALUES.*\\\$"              # Direct variable insertion
        "UPDATE.*SET.*=.*\\\$"                   # Direct variable in UPDATE
        "DELETE FROM.*WHERE.*\\\$"               # Direct variable in DELETE
        '"\s*\+\s*.*\s*\+\s*".*SELECT'          # String concat with SELECT
        "'\s*\+\s*.*\s*\+\s*'.*SELECT"          # String concat with SELECT
        'f".*SELECT.*{.*}"'                      # Python f-string SQL
        'f".*INSERT.*{.*}"'                      # Python f-string SQL
        '`.*SELECT.*\\\$\{.*\}`'                 # JS template literal SQL
        "execute\s*\(\s*[\"'].*%s"              # Python % formatting in SQL
        "query\s*\(\s*[\"'].*\\\$"              # Direct variable in query
    )

    for pattern in "${sql_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "SQLi"; then
                echo "‚ö†Ô∏è SECURITY [SQLi]: Potential SQL injection - use parameterized queries" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    # === XSS (Cross-Site Scripting) ===
    local xss_patterns=(
        "innerHTML\s*=\s*"                       # Direct innerHTML assignment
        "outerHTML\s*=\s*"                       # Direct outerHTML assignment
        "document\.write\s*\("                   # document.write
        "\.html\s*\(\s*[^)]*\\\$"               # jQuery .html() with variable
        "dangerouslySetInnerHTML"                # React dangerous prop
        "v-html\s*="                             # Vue v-html directive
        "\[innerHTML\]\s*="                      # Angular innerHTML binding
        "<%=.*%>"                                # Unescaped ERB
        "\{\{.*\|.*safe.*\}\}"                   # Django/Jinja safe filter
        "Markup\s*\("                            # Flask Markup
        "render_template_string"                 # Flask template injection
    )

    for pattern in "${xss_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "XSS"; then
                echo "‚ö†Ô∏è SECURITY [XSS]: Potential XSS vulnerability - sanitize output" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    # === Command Injection ===
    local cmd_patterns=(
        "os\.system\s*\("                        # Python os.system
        "subprocess\.call\s*\(.*shell\s*=\s*True" # Python subprocess with shell
        "subprocess\.run\s*\(.*shell\s*=\s*True"  # Python subprocess with shell
        "exec\s*\(\s*\\\$"                       # PHP/bash exec with variable
        "shell_exec\s*\("                        # PHP shell_exec
        "passthru\s*\("                          # PHP passthru
        "system\s*\(\s*\\\$"                     # system() with variable
        "popen\s*\(\s*\\\$"                      # popen with variable
        "eval\s*\(\s*\\\$"                       # eval with variable
        '`\s*\\\$'                               # Backtick with variable
        "\|\s*bash"                              # Pipe to bash
        "child_process\.exec\s*\("               # Node child_process.exec
        "spawn\s*\(.*\{.*shell.*\}"              # Node spawn with shell
    )

    for pattern in "${cmd_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "CMDi"; then
                echo "‚ö†Ô∏è SECURITY [CMDi]: Potential command injection - avoid shell=True, sanitize input" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    # === Path Traversal / LFI / RFI ===
    local path_patterns=(
        "open\s*\(\s*\\\$"                       # open() with variable
        "file_get_contents\s*\(\s*\\\$"          # PHP file_get_contents
        "include\s*\(\s*\\\$"                    # PHP include with variable
        "require\s*\(\s*\\\$"                    # PHP require with variable
        "readFile\s*\(\s*\\\$"                   # Node readFile with variable
        "\.\./"                                  # Path traversal sequence
        "\.\.%2[fF]"                             # URL encoded traversal
        "php://input"                            # PHP input wrapper
        "php://filter"                           # PHP filter wrapper
        "file://"                                # File protocol
        "expect://"                              # Expect wrapper
        "data://"                                # Data protocol in file context
    )

    for pattern in "${path_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "LFI"; then
                echo "‚ö†Ô∏è SECURITY [LFI/RFI]: Potential path traversal - validate and sanitize paths" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    # === Hardcoded Secrets ===
    local secret_patterns=(
        "password\s*=\s*['\"][^'\"]{4,}['\"]"    # Hardcoded password
        "api_key\s*=\s*['\"][^'\"]{8,}['\"]"     # Hardcoded API key
        "secret\s*=\s*['\"][^'\"]{8,}['\"]"      # Hardcoded secret
        "token\s*=\s*['\"][^'\"]{8,}['\"]"       # Hardcoded token
        "AWS_SECRET_ACCESS_KEY"                  # AWS secret
        "PRIVATE_KEY.*BEGIN"                     # Private key
        "sk-[a-zA-Z0-9]{20,}"                    # OpenAI API key pattern
        "ghp_[a-zA-Z0-9]{36}"                    # GitHub token pattern
        "xox[baprs]-[a-zA-Z0-9]+"                # Slack token pattern
        "-----BEGIN RSA PRIVATE KEY-----"        # RSA private key
        "-----BEGIN OPENSSH PRIVATE KEY-----"    # OpenSSH private key
    )

    for pattern in "${secret_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "SECRETS"; then
                echo "‚ö†Ô∏è SECURITY [SECRETS]: Hardcoded secret detected - use environment variables" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    # === SSRF (Server-Side Request Forgery) ===
    local ssrf_patterns=(
        "requests\.get\s*\(\s*\\\$"              # Python requests with variable URL
        "urllib\.request\.urlopen\s*\(\s*\\\$"  # Python urllib with variable
        "curl_exec\s*\("                         # PHP curl
        "file_get_contents\s*\(\s*[\"']http"    # PHP remote file
        "fetch\s*\(\s*\\\$"                      # JS fetch with variable
        "axios\.\w+\s*\(\s*\\\$"                 # Axios with variable URL
        "http\.get\s*\(\s*\\\$"                  # Node http with variable
        "localhost"                              # Localhost access
        "127\.0\.0\.1"                           # Localhost IP
        "0\.0\.0\.0"                             # Any interface
        "169\.254\."                             # AWS metadata
        "metadata\.google"                       # GCP metadata
    )

    for pattern in "${ssrf_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "SSRF"; then
                echo "‚ö†Ô∏è SECURITY [SSRF]: Potential SSRF - validate and whitelist URLs" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    # === Insecure Deserialization ===
    local deser_patterns=(
        "pickle\.loads\s*\("                     # Python pickle
        "yaml\.load\s*\([^)]*Loader\s*="         # PyYAML unsafe load
        "yaml\.unsafe_load"                      # PyYAML unsafe
        "unserialize\s*\("                       # PHP unserialize
        "Marshal\.load"                          # Ruby Marshal
        "ObjectInputStream"                      # Java deserialization
        "readObject\s*\("                        # Java readObject
        "JSON\.parse.*eval"                      # JS JSON with eval
    )

    for pattern in "${deser_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "DESER"; then
                echo "‚ö†Ô∏è SECURITY [DESER]: Insecure deserialization - use safe loaders" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    # === XXE (XML External Entity) ===
    local xxe_patterns=(
        "<!ENTITY"                               # XML entity declaration
        "SYSTEM\s*[\"']file:"                    # External file entity
        "SYSTEM\s*[\"']http:"                    # External HTTP entity
        "etree\.parse\s*\("                      # Python lxml parse
        "XMLParser\s*\("                         # Python XMLParser
        "parseXML\s*\("                          # Generic XML parsing
        "DocumentBuilder"                        # Java XML parsing
        "SAXParser"                              # Java SAX
    )

    for pattern in "${xxe_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "XXE"; then
                echo "‚ö†Ô∏è SECURITY [XXE]: Potential XXE - disable external entities" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    # === Dangerous Commands ===
    local danger_patterns=(
        "rm -rf /"                               # Recursive root delete
        "rm -rf /\*"                             # Root wildcard delete
        "chmod 777"                              # World-writable permissions
        "chmod -R 777"                           # Recursive world-writable
        "> /dev/sd"                              # Write to disk device
        "mkfs\."                                 # Format filesystem
        "dd if=.*/dev/"                          # Raw disk operations
        ":(){.*:.*};:"                           # Fork bomb
        "wget.*\|\s*bash"                        # Download and execute
        "curl.*\|\s*bash"                        # Download and execute
        "curl.*\|\s*sh"                          # Download and execute
    )

    for pattern in "${danger_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            # Dangerous commands don't get false positive bypass - always flag
            echo "‚ö†Ô∏è SECURITY [DANGER]: Dangerous command detected: $pattern" >> "$VIOLATIONS_FILE"
            ((violations++))
            break
        fi
    done

    # === Weak Cryptography ===
    local crypto_patterns=(
        "md5\s*\("                               # MD5 hashing
        "sha1\s*\("                              # SHA1 hashing
        "DES\s*\("                               # DES encryption
        "ECB"                                    # ECB mode
        "random\.random\s*\("                    # Insecure random (Python)
        "Math\.random\s*\("                      # Insecure random (JS)
        "rand\s*\(\s*\)"                         # Insecure random (PHP/C)
        "password.*plaintext"                    # Plaintext password storage
    )

    for pattern in "${crypto_patterns[@]}"; do
        if grep -qiE "$pattern" <<< "$output"; then
            if ! is_false_positive "$output" "CRYPTO"; then
                echo "‚ö†Ô∏è SECURITY [CRYPTO]: Weak cryptography - use strong algorithms" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
            break
        fi
    done

    [ "$violations" -gt 0 ] && return 1 || return 0
}

# ============================================================================
# CLAUDE.MD GENERATION
# ============================================================================

generate_claude_md() {
    local target_file="$1"

    cat > "$target_file" << 'CLAUDE_MD_EOF'
# CLAUDE.md - Project Rules

## Anti-Slop Rules
- NO greeting phrases: "I'd be happy to", "Let me", "Here's", "Great question"
- NO preamble - start directly with code or action
- NO filler words or excessive explanation
- Be terse and direct

## Code Quality
- NO placeholders: TODO, TBD, FIXME, pass, stub, unimplemented!
- NO incomplete implementations
- Every function must be fully implemented
- Include error handling

## Testing Requirements
- Include tests with every code change
- Tests must pass before considering work complete

## Workflow
- Use patch/edit mode for existing files
- One feature at a time
- Commit after completing each feature

## Security
- No hardcoded secrets or API keys
- Validate all user input
- Use parameterized queries for databases
CLAUDE_MD_EOF
}

run_interactive_mode() {
    local claude_md="$WORK_DIR/CLAUDE.md"

    if [ ! -f "$claude_md" ]; then
        echo -e "${CYAN}üìù Creating CLAUDE.md with enforcement rules...${NC}"
        generate_claude_md "$claude_md"
        echo -e "${GREEN}‚úÖ Created CLAUDE.md${NC}"
    fi

    exec "$CLAUDE_REAL" "$@"
}

run_raw_mode() {
    if [ -n "$TASK_ARGS" ]; then
        exec "$CLAUDE_REAL" $TASK_ARGS
    else
        exec "$CLAUDE_REAL"
    fi
}

# ============================================================================
# SESSION MODE DETECTION
# ============================================================================

detect_session_mode() {
    if [ ! -f "$PROGRESS_FILE" ]; then
        echo "initializer"
    else
        echo "continuing"
    fi
}

get_session_number() {
    local count=0
    if [ -f "$PROGRESS_FILE" ]; then
        count=$(grep -c "## Session" "$PROGRESS_FILE" 2>/dev/null || echo 0)
    fi
    echo "$count"
}

# ============================================================================
# GOLDEN TICKETS (BYPASS FOR HELP/EXPLAIN)
# ============================================================================

check_golden_ticket() {
    local input="$1"

    local patterns=(
        "^explain"
        "^what is"
        "^how does"
        "^why does"
        "^help$"
        "^status$"
    )

    for pattern in "${patterns[@]}"; do
        if grep -qiE "$pattern" <<< "$input"; then
            return 0
        fi
    done

    return 1
}

# ============================================================================
# ENFORCEMENT FUNCTIONS
# ============================================================================

is_slop_false_positive() {
    local output="$1"
    local pattern="$2"

    # Check if pattern appears in code block (between ``` markers)
    if grep -qE '```.*'"$pattern"'.*```|`[^`]*'"$pattern"'[^`]*`' <<< "$output"; then
        return 0
    fi

    # Check if in quoted text or string literal
    if grep -qE '"[^"]*'"$pattern"'[^"]*"|'"'"'[^'"'"']*'"$pattern"'[^'"'"']*'"'" <<< "$output"; then
        return 0
    fi

    # Check if explaining/describing (meta discussion)
    if grep -qiE "(avoid|don't use|instead of|rather than|not|bad|wrong).*$pattern" <<< "$output"; then
        return 0
    fi

    return 1
}

enforce_no_slop() {
    local output="$1"
    local violations=0

    local patterns=(
        "I'd be happy to"
        "I'll help you"
        "Let me"
        "Let's"
        "Here's"
        "Here is"
        "Great question"
        "I understand"
        "I can help"
        "I will"
        "I've created"
        "I've made"
    )

    for p in "${patterns[@]}"; do
        if grep -qi "$p" <<< "$output"; then
            if ! is_slop_false_positive "$output" "$p"; then
                echo "‚ùå SLOP: '$p'" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
        fi
    done

    [ "$violations" -gt 0 ] && return 1 || return 0
}

is_placeholder_false_positive() {
    local output="$1"
    local pattern="$2"

    # Skip if discussing/explaining placeholders (meta discussion)
    if grep -qiE "(remove|fix|replace|found|existing|old|current|has a|contains).*$pattern" <<< "$output"; then
        return 0
    fi

    # Skip if in grep/search command output showing file contents
    if grep -qE "^\s*[0-9]+[:-].*$pattern|^[a-zA-Z0-9_/.-]+:[0-9]+:.*$pattern" <<< "$output"; then
        return 0
    fi

    # Skip if showing diff output (identifying what to fix)
    if grep -qE "^[-+].*$pattern|^@@.*@@" <<< "$output"; then
        return 0
    fi

    # Skip if in TODO.md or tracking file context
    if grep -qiE "(TODO\.md|todo list|task list|checklist)" <<< "$output"; then
        return 0
    fi

    return 1
}

enforce_no_placeholders() {
    local output="$1"
    local violations=0

    local patterns=(
        "TODO"
        "TBD"
        "FIXME"
        "# TODO: pass"
        "unimplemented!"
        "todo!"
        "NotImplementedError"
    )

    for p in "${patterns[@]}"; do
        if grep -qE "$p" <<< "$output"; then
            if ! is_placeholder_false_positive "$output" "$p"; then
                echo "‚ùå PLACEHOLDER: '$p'" >> "$VIOLATIONS_FILE"
                ((violations++))
            fi
        fi
    done

    [ "$violations" -gt 0 ] && return 1 || return 0
}

enforce_harness_compliance() {
    local output="$1"
    local mode="$2"
    local violations=0

    if [ "$mode" = "continuing" ]; then
        if ! grep -qiE "(session|progress|feature|complete|implement)" <<< "$output"; then
            echo "‚ùå HARNESS: Did not acknowledge progress file" >> "$VIOLATIONS_FILE"
            ((violations++))
        fi
    elif [ "$mode" = "initializer" ]; then
        if ! grep -qE "(claude-progress.txt|features.json)" <<< "$output"; then
            echo "‚ùå HARNESS: Did not create harness files" >> "$VIOLATIONS_FILE"
            ((violations++))
        fi
    fi

    [ "$violations" -gt 0 ] && return 1 || return 0
}

# ============================================================================
# HARNESS PROMPTS
# ============================================================================

build_initializer_prompt() {
    local task="$1"
    cat << 'EOF'
You are starting a NEW PROJECT. This is the FIRST session.

MANDATORY SEQUENCE:
1. Create claude-progress.txt with project header
2. Create features.json with COMPREHENSIVE feature list:
   - Target 200+ granular features for full coverage
   - Each feature should be atomic and testable
   - Include edge cases, error handling, UI states
   - Example: "user can click new chat button and see empty chat"
   - All features start with "passes": false
3. Create init.sh for dev environment setup
4. Implement exactly ONE feature
5. VERIFY the feature works (see verification rules below)
6. Update progress file
7. Commit your work

FEATURE LIST FORMAT (features.json):
{
  "features": [
    {
      "id": "feature-001",
      "category": "functional|ui|error-handling|edge-case",
      "description": "Specific testable behavior",
      "verification": "How to verify this works",
      "passes": false
    }
  ]
}

RULES:
- Create 200+ features for comprehensive coverage
- Work on ONLY ONE feature this session
- Include tests for the feature
- No placeholders (TODO, pass, stub)
EOF
    echo ""
    echo "Task: $task"
}

build_continuing_prompt() {
    local task="$1"
    local session_num="$2"
    local display_num=$((session_num + 1))

    cat << EOF
You are CONTINUING an existing project. Session #${display_num}.

STARTUP SEQUENCE:
1. Run: cat claude-progress.txt (show last 3 entries)
2. Run: git log --oneline -5 (show recent commits)
3. Run: ./init.sh (verify environment starts)
4. Run: cat features.json (pick ONE with "passes": false)
5. State which feature you will work on

WORK RULES:
- Work on EXACTLY ONE feature
- Include comprehensive tests

VERIFICATION RULES (MANDATORY before marking "passes": true):
- For web apps: Use Puppeteer MCP to test as a real user would
  - Navigate to the page
  - Perform the user action
  - Verify the expected result visually
  - Take a screenshot as evidence
- For CLI/API: Run actual commands and verify output
- For libraries: Write and run integration tests
- NEVER mark a feature as passing without E2E verification
- If Puppeteer MCP unavailable, use curl/browser dev tools

COMPLETION RULES:
- Update claude-progress.txt when done
- Mark feature "passes": true ONLY after verification succeeds
- Commit with descriptive message
- No placeholders

Task: $task
EOF
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

run_harness() {
    local enforced_prompt="$1"
    local session_mode="$2"

    local MAX_RETRIES=3
    local retry_count=0
    local success=0

    > "$VIOLATIONS_FILE"

    while [ "$retry_count" -lt "$MAX_RETRIES" ]; do
        echo -e "${CYAN}üöÄ Attempt $((retry_count + 1))/$MAX_RETRIES${NC}"

        "$CLAUDE_REAL" --dangerously-skip-permissions -p "$enforced_prompt" 2>&1 | tee "$OUTPUT_FILE"
        local OUTPUT
        OUTPUT="$(cat "$OUTPUT_FILE")"

        > "$VIOLATIONS_FILE"

        # Run all checks
        enforce_no_slop "$OUTPUT" || true
        enforce_no_placeholders "$OUTPUT" || true
        enforce_harness_compliance "$OUTPUT" "$session_mode" || true
        check_security "$OUTPUT" || true

        # Quality hints (non-blocking)
        > "$COMPLEXITY_FILE"
        check_complexity "$OUTPUT" || true
        check_test_coverage "$OUTPUT" || true
        check_performance "$OUTPUT" || true

        if [ ! -s "$VIOLATIONS_FILE" ]; then
            echo -e "${GREEN}‚úÖ All checks passed${NC}"

            # Show quality hints if any
            if [ -s "$COMPLEXITY_FILE" ]; then
                echo ""
                echo -e "${YELLOW}üìã Quality Hints (non-blocking):${NC}"
                cat "$COMPLEXITY_FILE"
            fi

            success=1
            break
        fi

        echo -e "${RED}‚ùå Violations detected:${NC}"
        cat "$VIOLATIONS_FILE"

        retry_count=$((retry_count + 1))

        if [ "$retry_count" -lt "$MAX_RETRIES" ]; then
            echo -e "${YELLOW}Retrying with violation feedback...${NC}"
            enforced_prompt="VIOLATIONS DETECTED - Please fix:
$(cat "$VIOLATIONS_FILE")

$enforced_prompt"
        fi
    done

    if [ "$success" -eq 0 ]; then
        echo -e "${RED}‚ö†Ô∏è Max retries reached with violations${NC}"
        echo -e "${YELLOW}Use 'claude --rollback' to restore previous state${NC}"
    fi
}

# Parse arguments
parse_arguments "$@"

# Raw mode
if [ "$RAW_MODE" = "true" ]; then
    run_raw_mode
fi

# Interactive mode
if [ "$INTERACTIVE_MODE" = "true" ]; then
    run_interactive_mode
fi

# Harness mode - prompt for task if needed
if [ "$HARNESS_MODE" = "true" ] && [ -z "$TASK_ARGS" ]; then
    echo -e "${CYAN}Enter your task:${NC}"
    read -r TASK_ARGS
    if [ -z "$TASK_ARGS" ]; then
        echo -e "${RED}No task provided.${NC}"
        exit 1
    fi
fi

# Default to harness mode if args given
if [ -z "$HARNESS_MODE" ] && [ -n "$TASK_ARGS" ]; then
    HARNESS_MODE="true"
fi

if [ -z "$HARNESS_MODE" ]; then
    run_interactive_mode
fi

# Detect session
SESSION_MODE="$(detect_session_mode)"
SESSION_NUM="$(get_session_number)"
DISPLAY_SESSION=$((SESSION_NUM + 1))

# Header
echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
echo -e "${CYAN}‚ïë${NC}  ${MAGENTA}üîê CLAUDE HARNESS${NC}                                        ${CYAN}‚ïë${NC}"
echo -e "${CYAN}‚ïë${NC}  ${YELLOW}Mode: ${SESSION_MODE^^} | Session #${DISPLAY_SESSION}${NC}                       ${CYAN}‚ïë${NC}"
echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"

# Take snapshot BEFORE any changes
SNAPSHOT_ID="$(take_snapshot)"
echo -e "${GREEN}üì∏ Snapshot saved: $SNAPSHOT_ID${NC}"
echo -e "${CYAN}   Use 'claude --rollback' to restore if needed${NC}"

# Golden ticket check
if check_golden_ticket "$TASK_ARGS"; then
    echo -e "${YELLOW}üé´ Help/explain request - running directly${NC}"
    "$CLAUDE_REAL" --dangerously-skip-permissions -p "$TASK_ARGS" 2>&1
    exit 0
fi

# Build prompt
if [ "$SESSION_MODE" = "initializer" ]; then
    ENFORCED_PROMPT="$(build_initializer_prompt "$TASK_ARGS")"
else
    ENFORCED_PROMPT="$(build_continuing_prompt "$TASK_ARGS" "$SESSION_NUM")"
fi

# Add enforcement rules
ENFORCED_PROMPT="$ENFORCED_PROMPT

ENFORCEMENT:
- NO SLOP: No greetings or preambles
- NO PLACEHOLDERS: No TODO, pass, stub
- TESTS REQUIRED: Include tests
- SECURITY: No hardcoded secrets

HYBRID TOOLS (prefer bash tools for efficiency):
- Browser automation: cat ~/.claude/agent-tools/browser-tools/README.md (~225 tokens)
- Tool recommendation: python3 ~/.claude/middleware/hybrid_tools.py recommend 'task'
- Search all tools: python3 ~/.claude/middleware/hybrid_tools.py search 'query'
- Find skills: python3 ~/.claude/middleware/mcp_middleware.py find-skills 'query'
- Full guide: cat ~/.claude/agent-tools/TOOLS.md
- Save working code as skill when substantial and reusable

Start DIRECTLY with action/code."

# Load CLAUDE.md if present
if [ -f "CLAUDE.md" ]; then
    CLAUDE_RULES="$(head -50 CLAUDE.md 2>/dev/null || echo "")"
    ENFORCED_PROMPT="$ENFORCED_PROMPT

Project rules:
$CLAUDE_RULES"
fi

echo ""
run_harness "$ENFORCED_PROMPT" "$SESSION_MODE"

# Post-session status
echo ""
echo -e "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
echo -e "${CYAN}üìä Session Summary${NC}"
echo -e "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"

if [ -f "$FEATURES_FILE" ] && command -v jq >/dev/null 2>&1; then
    PENDING=$(jq '[.features[] | select(.passes == false)] | length' "$FEATURES_FILE" 2>/dev/null || echo "?")
    DONE=$(jq '[.features[] | select(.passes == true)] | length' "$FEATURES_FILE" 2>/dev/null || echo "?")
    echo -e "${CYAN}Features: ${GREEN}$DONE done${NC} / ${YELLOW}$PENDING pending${NC}"
fi

if git status --porcelain 2>/dev/null | grep -q .; then
    echo -e "${YELLOW}üìù Uncommitted changes - review and commit${NC}"
else
    echo -e "${GREEN}‚úÖ Working tree clean${NC}"
fi

echo -e "${CYAN}Snapshot: $SNAPSHOT_ID (use --rollback to restore)${NC}"

# Update metrics
VIOLATION_COUNT=$(wc -l < "$VIOLATIONS_FILE" 2>/dev/null || echo 0)
update_metrics "$VIOLATION_COUNT" "$DISPLAY_SESSION" "$([ -s "$VIOLATIONS_FILE" ] && echo 0 || echo 1)"

# Save context for next session
save_context

echo -e "${CYAN}Use 'claude --metrics' to view session history${NC}"

# ============================================================================
# AUTO-CONTINUE MODE
# ============================================================================

check_project_complete() {
    # Check if all features are done
    if [ -f "$FEATURES_FILE" ] && command -v jq >/dev/null 2>&1; then
        local pending
        pending=$(jq '[.features[] | select(.passes == false)] | length' "$FEATURES_FILE" 2>/dev/null || echo "1")
        if [ "$pending" -eq 0 ]; then
            return 0  # Complete
        fi
    fi
    return 1  # Not complete
}

if [ "$AUTO_MODE" = "true" ]; then
    echo ""
    echo -e "${MAGENTA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${MAGENTA}üîÑ AUTO MODE - Checking if more work needed...${NC}"
    echo -e "${MAGENTA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"

    AUTO_SESSION_COUNT=1

    while ! check_project_complete; do
        ((AUTO_SESSION_COUNT++))

        # Check how many features remain
        if [ -f "$FEATURES_FILE" ] && command -v jq >/dev/null 2>&1; then
            REMAINING=$(jq '[.features[] | select(.passes == false)] | length' "$FEATURES_FILE" 2>/dev/null || echo "?")
            echo ""
            echo -e "${CYAN}üìã $REMAINING features remaining - starting session $AUTO_SESSION_COUNT...${NC}"
        else
            echo ""
            echo -e "${CYAN}üîÑ Continuing to next session ($AUTO_SESSION_COUNT)...${NC}"
        fi

        sleep 2  # Brief pause between sessions

        # Re-detect session mode (should be "continuing" now)
        SESSION_MODE="$(detect_session_mode)"
        SESSION_NUM="$(get_session_number)"
        DISPLAY_SESSION=$((SESSION_NUM + 1))

        # Take new snapshot
        SNAPSHOT_ID="$(take_snapshot)"
        echo -e "${GREEN}üì∏ Snapshot: $SNAPSHOT_ID${NC}"

        # Build continuing prompt
        ENFORCED_PROMPT="$(build_continuing_prompt "$TASK_ARGS" "$SESSION_NUM")"

        # Append enforcement rules
        ENFORCED_PROMPT="$ENFORCED_PROMPT

ENFORCEMENT:
- NO SLOP: No greetings or preambles
- NO PLACEHOLDERS: No TODO, pass, stub
- TESTS REQUIRED: Include tests
- SECURITY: No hardcoded secrets

Start DIRECTLY with action/code."

        # Add CLAUDE.md rules if present
        if [ -f "CLAUDE.md" ]; then
            CLAUDE_RULES="$(head -50 CLAUDE.md 2>/dev/null || echo "")"
            ENFORCED_PROMPT="$ENFORCED_PROMPT

Project rules:
$CLAUDE_RULES"
        fi

        echo ""
        echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
        echo -e "${CYAN}‚ïë${NC}  ${MAGENTA}üîÑ AUTO SESSION #${AUTO_SESSION_COUNT}${NC}                                    ${CYAN}‚ïë${NC}"
        echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"
        echo ""

        # Run harness
        run_harness "$ENFORCED_PROMPT" "$SESSION_MODE"

        # Update metrics
        VIOLATION_COUNT=$(wc -l < "$VIOLATIONS_FILE" 2>/dev/null || echo 0)
        update_metrics "$VIOLATION_COUNT" "$DISPLAY_SESSION" "$([ -s "$VIOLATIONS_FILE" ] && echo 0 || echo 1)"

        # Save context
        save_context
    done

    echo ""
    echo -e "${GREEN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${GREEN}üéâ PROJECT COMPLETE! All features implemented.${NC}"
    echo -e "${GREEN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${CYAN}Total auto sessions: $AUTO_SESSION_COUNT${NC}"
fi
