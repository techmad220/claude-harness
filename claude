#!/bin/bash
# Claude Harness - Quality Enforcement for Claude CLI
# Implements code quality gates and session tracking
#
# Usage:
#   claude                    - Interactive mode (auto-creates CLAUDE.md)
#   claude "Build X"          - Full harness mode with enforcement
#   claude --harness          - Force harness mode
#   claude --raw [args]       - Bypass harness, run Claude directly

set -euo pipefail

# =========================================================================
# CONFIGURATION
# =========================================================================

# Find the real Claude binary
if [ -x "$HOME/.local/bin/claude.real" ]; then
    CLAUDE_REAL="$HOME/.local/bin/claude.real"
elif [ -d "$HOME/.local/share/claude/versions" ]; then
    CLAUDE_REAL=$(ls -t "$HOME/.local/share/claude/versions"/* 2>/dev/null | head -1)
else
    echo "ERROR: Cannot find Claude binary" >&2
    echo "Install Claude CLI first, then rename it to claude.real" >&2
    exit 1
fi

# ============================================================================
# ARGUMENT PARSING
# ============================================================================

HARNESS_MODE=""
RAW_MODE=""
INTERACTIVE_MODE=""
TASK_ARGS=""

show_help() {
    cat << 'EOF'
Claude Harness - Quality Enforcement

USAGE:
  claude                    Interactive mode (creates CLAUDE.md if needed)
  claude "task description" Full harness mode with enforcement
  claude --harness          Force harness mode
  claude --raw [args]       Bypass harness, run Claude directly
  claude --rollback         Restore last snapshot

FLAGS:
  --raw         Bypass all harness logic
  --harness     Force harness mode
  --rollback    Restore previous snapshot
  -h, --help    Show this help

ENFORCEMENT:
  - No slop (greeting phrases, filler)
  - No placeholders (TODO, FIXME, pass, stub)
  - Session tracking (initializer/continuing modes)
  - Git snapshots before changes
EOF
}

parse_arguments() {
    if [ $# -eq 0 ]; then
        INTERACTIVE_MODE="true"
        return
    fi

    while [ $# -gt 0 ]; do
        case "$1" in
            --raw)
                RAW_MODE="true"
                shift
                TASK_ARGS="$*"
                return
                ;;
            --harness)
                HARNESS_MODE="true"
                shift
                if [ $# -gt 0 ]; then
                    TASK_ARGS="$*"
                fi
                return
                ;;
            --rollback)
                do_rollback
                exit 0
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                HARNESS_MODE="true"
                TASK_ARGS="$*"
                return
                ;;
        esac
    done
}

# ============================================================================
# GLOBALS
# ============================================================================

WORK_DIR="$(pwd)"
SESSION_ID="$(date +%s)-$$"
SESSION_DIR="/tmp/claude-$SESSION_ID"
SNAPSHOT_DIR="$HOME/.claude/snapshots"
VIOLATIONS_LOG="$HOME/.claude/violations.log"

PROGRESS_FILE="$WORK_DIR/claude-progress.txt"
FEATURES_FILE="$WORK_DIR/features.json"

OUTPUT_FILE="$SESSION_DIR/output.txt"
VIOLATIONS_FILE="$SESSION_DIR/violations.txt"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

mkdir -p "$SESSION_DIR" "$SNAPSHOT_DIR"
trap 'rm -rf "$SESSION_DIR"' EXIT

# ============================================================================
# SNAPSHOT SYSTEM (ROLLBACK SAFETY)
# ============================================================================

take_snapshot() {
    local snap_id="snap-$SESSION_ID"
    local snap_path="$SNAPSHOT_DIR/$snap_id"

    if git rev-parse --git-dir >/dev/null 2>&1; then
        git stash push -m "claude-harness-$snap_id" --include-untracked 2>/dev/null || true
        git rev-parse HEAD > "$snap_path.commit" 2>/dev/null || true
        git stash pop 2>/dev/null || true

        # Also save diff for non-stash rollback
        git diff HEAD > "$snap_path.diff" 2>/dev/null || true
        git status --porcelain > "$snap_path.status" 2>/dev/null || true
    fi

    # Save file hashes for verification
    find . -type f \( -name "*.py" -o -name "*.js" -o -name "*.ts" -o -name "*.rs" -o -name "*.go" \) 2>/dev/null | \
        head -100 | while IFS= read -r f; do
            sha256sum "$f" 2>/dev/null || true
        done > "$snap_path.hashes"

    # Remember last snapshot
    echo "$snap_id" > "$SNAPSHOT_DIR/latest"

    echo "$snap_id"
}

do_rollback() {
    if [ ! -f "$SNAPSHOT_DIR/latest" ]; then
        echo -e "${RED}No snapshot available to rollback${NC}"
        exit 1
    fi

    local snap_id=$(cat "$SNAPSHOT_DIR/latest")
    local snap_path="$SNAPSHOT_DIR/$snap_id"

    echo -e "${YELLOW}Rolling back to snapshot: $snap_id${NC}"

    if [ -f "$snap_path.commit" ] && git rev-parse --git-dir >/dev/null 2>&1; then
        local commit=$(cat "$snap_path.commit")
        echo -e "${CYAN}Resetting to commit: $commit${NC}"
        git reset --hard "$commit" 2>/dev/null || true

        if [ -f "$snap_path.diff" ] && [ -s "$snap_path.diff" ]; then
            echo -e "${CYAN}Applying saved changes...${NC}"
            git apply "$snap_path.diff" 2>/dev/null || true
        fi
    fi

    echo -e "${GREEN}‚úÖ Rollback complete${NC}"
}

# ============================================================================
# SECURITY CHECKS
# ============================================================================

check_security() {
    local output="$1"
    local violations=0

    # Check for hardcoded secrets
    local secret_patterns=(
        "password\s*=\s*['\"][^'\"]+['\"]"
        "api_key\s*=\s*['\"][^'\"]+['\"]"
        "secret\s*=\s*['\"][^'\"]+['\"]"
        "token\s*=\s*['\"][^'\"]+['\"]"
        "AWS_SECRET"
        "PRIVATE_KEY"
    )

    for pattern in "${secret_patterns[@]}"; do
        if grep -qiE "$pattern" <<< "$output"; then
            echo "‚ö†Ô∏è SECURITY: Possible hardcoded secret detected" >> "$VIOLATIONS_FILE"
            ((violations++))
        fi
    done

    # Check for dangerous commands
    local danger_patterns=(
        "rm -rf /"
        "chmod 777"
        "eval\s*\("
        "> /dev/sd"
        "mkfs\."
    )

    for pattern in "${danger_patterns[@]}"; do
        if grep -qE "$pattern" <<< "$output"; then
            echo "‚ö†Ô∏è SECURITY: Dangerous command detected: $pattern" >> "$VIOLATIONS_FILE"
            ((violations++))
        fi
    done

    [ "$violations" -gt 0 ] && return 1 || return 0
}

# ============================================================================
# CLAUDE.MD GENERATION
# ============================================================================

generate_claude_md() {
    local target_file="$1"

    cat > "$target_file" << 'CLAUDE_MD_EOF'
# CLAUDE.md - Project Rules

## Anti-Slop Rules
- NO greeting phrases: "I'd be happy to", "Let me", "Here's", "Great question"
- NO preamble - start directly with code or action
- NO filler words or excessive explanation
- Be terse and direct

## Code Quality
- NO placeholders: TODO, TBD, FIXME, pass, stub, unimplemented!
- NO incomplete implementations
- Every function must be fully implemented
- Include error handling

## Testing Requirements
- Include tests with every code change
- Tests must pass before considering work complete

## Workflow
- Use patch/edit mode for existing files
- One feature at a time
- Commit after completing each feature

## Security
- No hardcoded secrets or API keys
- Validate all user input
- Use parameterized queries for databases
CLAUDE_MD_EOF
}

run_interactive_mode() {
    local claude_md="$WORK_DIR/CLAUDE.md"

    if [ ! -f "$claude_md" ]; then
        echo -e "${CYAN}üìù Creating CLAUDE.md with enforcement rules...${NC}"
        generate_claude_md "$claude_md"
        echo -e "${GREEN}‚úÖ Created CLAUDE.md${NC}"
    fi

    exec "$CLAUDE_REAL" "$@"
}

run_raw_mode() {
    if [ -n "$TASK_ARGS" ]; then
        exec "$CLAUDE_REAL" $TASK_ARGS
    else
        exec "$CLAUDE_REAL"
    fi
}

# ============================================================================
# SESSION MODE DETECTION
# ============================================================================

detect_session_mode() {
    if [ ! -f "$PROGRESS_FILE" ]; then
        echo "initializer"
    else
        echo "continuing"
    fi
}

get_session_number() {
    local count=0
    if [ -f "$PROGRESS_FILE" ]; then
        count=$(grep -c "## Session" "$PROGRESS_FILE" 2>/dev/null || echo 0)
    fi
    echo "$count"
}

# ============================================================================
# GOLDEN TICKETS (BYPASS FOR HELP/EXPLAIN)
# ============================================================================

check_golden_ticket() {
    local input="$1"

    local patterns=(
        "^explain"
        "^what is"
        "^how does"
        "^why does"
        "^help$"
        "^status$"
    )

    for pattern in "${patterns[@]}"; do
        if grep -qiE "$pattern" <<< "$input"; then
            return 0
        fi
    done

    return 1
}

# ============================================================================
# ENFORCEMENT FUNCTIONS
# ============================================================================

enforce_no_slop() {
    local output="$1"
    local violations=0

    local patterns=(
        "I'd be happy to"
        "I'll help you"
        "Let me"
        "Let's"
        "Here's"
        "Here is"
        "Great question"
        "I understand"
        "I can help"
        "I will"
        "I've created"
        "I've made"
    )

    for p in "${patterns[@]}"; do
        if grep -qi "$p" <<< "$output"; then
            echo "‚ùå SLOP: '$p'" >> "$VIOLATIONS_FILE"
            ((violations++))
        fi
    done

    [ "$violations" -gt 0 ] && return 1 || return 0
}

enforce_no_placeholders() {
    local output="$1"
    local violations=0

    local patterns=(
        "TODO"
        "TBD"
        "FIXME"
        "# TODO: pass"
        "unimplemented!"
        "todo!"
        "NotImplementedError"
    )

    for p in "${patterns[@]}"; do
        if grep -qE "$p" <<< "$output"; then
            echo "‚ùå PLACEHOLDER: '$p'" >> "$VIOLATIONS_FILE"
            ((violations++))
        fi
    done

    [ "$violations" -gt 0 ] && return 1 || return 0
}

enforce_harness_compliance() {
    local output="$1"
    local mode="$2"
    local violations=0

    if [ "$mode" = "continuing" ]; then
        if ! grep -qiE "(session|progress|feature|complete|implement)" <<< "$output"; then
            echo "‚ùå HARNESS: Did not acknowledge progress file" >> "$VIOLATIONS_FILE"
            ((violations++))
        fi
    elif [ "$mode" = "initializer" ]; then
        if ! grep -qE "(claude-progress.txt|features.json)" <<< "$output"; then
            echo "‚ùå HARNESS: Did not create harness files" >> "$VIOLATIONS_FILE"
            ((violations++))
        fi
    fi

    [ "$violations" -gt 0 ] && return 1 || return 0
}

# ============================================================================
# HARNESS PROMPTS
# ============================================================================

build_initializer_prompt() {
    local task="$1"
    cat << 'EOF'
You are starting a NEW PROJECT. This is the FIRST session.

MANDATORY SEQUENCE:
1. Create claude-progress.txt with project header
2. Create features.json listing ALL features needed
3. Create init.sh for dev environment setup
4. Implement exactly ONE feature
5. Update progress file
6. Commit your work

RULES:
- Work on ONLY ONE feature this session
- Include tests for the feature
- No placeholders (TODO, pass, stub)
EOF
    echo ""
    echo "Task: $task"
}

build_continuing_prompt() {
    local task="$1"
    local session_num="$2"
    local display_num=$((session_num + 1))

    cat << EOF
You are CONTINUING an existing project. Session #${display_num}.

STARTUP SEQUENCE:
1. Read claude-progress.txt - show last entries
2. Check git log -5
3. Read features.json - pick ONE with "passes": false
4. State which feature you will work on

RULES:
- Work on EXACTLY ONE feature
- Include tests
- Update progress when done
- Commit with descriptive message
- No placeholders

Task: $task
EOF
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

run_harness() {
    local enforced_prompt="$1"
    local session_mode="$2"

    local MAX_RETRIES=3
    local retry_count=0
    local success=0

    > "$VIOLATIONS_FILE"

    while [ "$retry_count" -lt "$MAX_RETRIES" ]; do
        echo -e "${CYAN}üöÄ Attempt $((retry_count + 1))/$MAX_RETRIES${NC}"

        "$CLAUDE_REAL" --dangerously-skip-permissions -p "$enforced_prompt" 2>&1 | tee "$OUTPUT_FILE"
        local OUTPUT
        OUTPUT="$(cat "$OUTPUT_FILE")"

        > "$VIOLATIONS_FILE"

        # Run all checks
        enforce_no_slop "$OUTPUT" || true
        enforce_no_placeholders "$OUTPUT" || true
        enforce_harness_compliance "$OUTPUT" "$session_mode" || true
        check_security "$OUTPUT" || true

        if [ ! -s "$VIOLATIONS_FILE" ]; then
            echo -e "${GREEN}‚úÖ All checks passed${NC}"
            success=1
            break
        fi

        echo -e "${RED}‚ùå Violations detected:${NC}"
        cat "$VIOLATIONS_FILE"

        retry_count=$((retry_count + 1))

        if [ "$retry_count" -lt "$MAX_RETRIES" ]; then
            echo -e "${YELLOW}Retrying with violation feedback...${NC}"
            enforced_prompt="VIOLATIONS DETECTED - Please fix:
$(cat "$VIOLATIONS_FILE")

$enforced_prompt"
        fi
    done

    if [ "$success" -eq 0 ]; then
        echo -e "${RED}‚ö†Ô∏è Max retries reached with violations${NC}"
        echo -e "${YELLOW}Use 'claude --rollback' to restore previous state${NC}"
    fi
}

# Parse arguments
parse_arguments "$@"

# Raw mode
if [ "$RAW_MODE" = "true" ]; then
    run_raw_mode
fi

# Interactive mode
if [ "$INTERACTIVE_MODE" = "true" ]; then
    run_interactive_mode
fi

# Harness mode - prompt for task if needed
if [ "$HARNESS_MODE" = "true" ] && [ -z "$TASK_ARGS" ]; then
    echo -e "${CYAN}Enter your task:${NC}"
    read -r TASK_ARGS
    if [ -z "$TASK_ARGS" ]; then
        echo -e "${RED}No task provided.${NC}"
        exit 1
    fi
fi

# Default to harness mode if args given
if [ -z "$HARNESS_MODE" ] && [ -n "$TASK_ARGS" ]; then
    HARNESS_MODE="true"
fi

if [ -z "$HARNESS_MODE" ]; then
    run_interactive_mode
fi

# Detect session
SESSION_MODE="$(detect_session_mode)"
SESSION_NUM="$(get_session_number)"
DISPLAY_SESSION=$((SESSION_NUM + 1))

# Header
echo -e "${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó${NC}"
echo -e "${CYAN}‚ïë${NC}  ${MAGENTA}üîê CLAUDE HARNESS${NC}                                        ${CYAN}‚ïë${NC}"
echo -e "${CYAN}‚ïë${NC}  ${YELLOW}Mode: ${SESSION_MODE^^} | Session #${DISPLAY_SESSION}${NC}                       ${CYAN}‚ïë${NC}"
echo -e "${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù${NC}"

# Take snapshot BEFORE any changes
SNAPSHOT_ID="$(take_snapshot)"
echo -e "${GREEN}üì∏ Snapshot saved: $SNAPSHOT_ID${NC}"
echo -e "${CYAN}   Use 'claude --rollback' to restore if needed${NC}"

# Golden ticket check
if check_golden_ticket "$TASK_ARGS"; then
    echo -e "${YELLOW}üé´ Help/explain request - running directly${NC}"
    "$CLAUDE_REAL" --dangerously-skip-permissions -p "$TASK_ARGS" 2>&1
    exit 0
fi

# Build prompt
if [ "$SESSION_MODE" = "initializer" ]; then
    ENFORCED_PROMPT="$(build_initializer_prompt "$TASK_ARGS")"
else
    ENFORCED_PROMPT="$(build_continuing_prompt "$TASK_ARGS" "$SESSION_NUM")"
fi

# Add enforcement rules
ENFORCED_PROMPT="$ENFORCED_PROMPT

ENFORCEMENT:
- NO SLOP: No greetings or preambles
- NO PLACEHOLDERS: No TODO, pass, stub
- TESTS REQUIRED: Include tests
- SECURITY: No hardcoded secrets

Start DIRECTLY with action/code."

# Load CLAUDE.md if present
if [ -f "CLAUDE.md" ]; then
    CLAUDE_RULES="$(head -50 CLAUDE.md 2>/dev/null || echo "")"
    ENFORCED_PROMPT="$ENFORCED_PROMPT

Project rules:
$CLAUDE_RULES"
fi

echo ""
run_harness "$ENFORCED_PROMPT" "$SESSION_MODE"

# Post-session status
echo ""
echo -e "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
echo -e "${CYAN}üìä Session Summary${NC}"
echo -e "${CYAN}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"

if [ -f "$FEATURES_FILE" ] && command -v jq >/dev/null 2>&1; then
    PENDING=$(jq '[.features[] | select(.passes == false)] | length' "$FEATURES_FILE" 2>/dev/null || echo "?")
    DONE=$(jq '[.features[] | select(.passes == true)] | length' "$FEATURES_FILE" 2>/dev/null || echo "?")
    echo -e "${CYAN}Features: ${GREEN}$DONE done${NC} / ${YELLOW}$PENDING pending${NC}"
fi

if git status --porcelain 2>/dev/null | grep -q .; then
    echo -e "${YELLOW}üìù Uncommitted changes - review and commit${NC}"
else
    echo -e "${GREEN}‚úÖ Working tree clean${NC}"
fi

echo -e "${CYAN}Snapshot: $SNAPSHOT_ID (use --rollback to restore)${NC}"
